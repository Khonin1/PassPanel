#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import RPi.GPIO as GPIO
import serial
import time
import sqlite3
import json
from gpiozero import Button
import paho.mqtt.client as mqtt
from datetime import datetime

# Инициализация базы данных
def init_db():
    conn = sqlite3.connect('keys_database.db')
    cursor = conn.cursor()
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS keys (
        key_code BLOB PRIMARY KEY,
        name TEXT,
        last_used TIMESTAMP
    )
    ''')
    conn.commit()
    return conn, cursor

conn, cursor = init_db()

# Настройки MQTT
MQTT_BROKER = "localhost"
MQTT_PORT = 1883
MQTT_USERNAME = "admin"
MQTT_PASSWORD = "milk"
MQTT_TOPIC_CONTROL = "door/control"
MQTT_TOPIC_STATUS = "door/status"
MQTT_TOPIC_EVENTS = "door/events"

# Состояние системы
class DoorState:
    def __init__(self):
        self.light_status = None
        self.mode = True  # True = Short mode, False = Long mode
        self.block_mode = False
        self.door_open = False
        self.last_event = None

door_state = DoorState()

# Настройки кнопки
LONG_PRESS_TIME = 1.5
DOUBLE_PRESS_INTERVAL = 0.3
WAIT_FOR_PRESS_TIMEOUT = 0.1

# Конфигурация GPIO
GPIO.setmode(GPIO.BCM)
RS485_ENABLE_PIN = 4
OPEN_PIN = 17
BUTTON_PIN = 22
RED_LIGHT_PIN = 27
GREEN_LIGHT_PIN = 5

GPIO.setup(RS485_ENABLE_PIN, GPIO.OUT)
GPIO.setup(OPEN_PIN, GPIO.OUT)
GPIO.setup(RED_LIGHT_PIN, GPIO.OUT)
GPIO.setup(GREEN_LIGHT_PIN, GPIO.OUT)
GPIO.output(RS485_ENABLE_PIN, GPIO.LOW)
GPIO.output(OPEN_PIN, GPIO.LOW)

button = Button(BUTTON_PIN, bounce_time=0.05)

# Настройка последовательного порта
ser = serial.Serial(
    port='/dev/ttyS0',
    baudrate=9600,
    bytesize=serial.EIGHTBITS,
    parity=serial.PARITY_NONE,
    stopbits=serial.STOPBITS_ONE,
    timeout=1
)

# Мастер-карты
MASTER_CARDS = {
    b'E\x19`$x\x03\x952\x07\x81\x19B\x03B4`7E\x80': 'Khonin Alexander'
}

def publish_status():
    status = {
        "door_open": door_state.door_open,
        "mode": "short" if door_state.mode else "long",
        "block_mode": door_state.block_mode,
        "light_status": door_state.light_status,
        "timestamp": datetime.now().isoformat()
    }
    client.publish(MQTT_TOPIC_STATUS, json.dumps(status), retain=True)

def publish_event(event_type, details=None):
    event = {
        "type": event_type,
        "timestamp": datetime.now().isoformat()
    }
    if details:
        event.update(details)
    client.publish(MQTT_TOPIC_EVENTS, json.dumps(event))

def insert_key(key_code, name):
    try:
        cursor.execute('''
        INSERT OR REPLACE INTO keys (key_code, name, last_used) 
        VALUES (?, ?, ?)
        ''', (key_code, name, datetime.now()))
        conn.commit()
        publish_event("key_added", {"key_code": str(key_code), "name": name})
        print(f"New card added: {name}")
    except sqlite3.Error as e:
        print(f"Database error: {e}")

def check_code_in_database(data):
    try:
        cursor.execute('''
        UPDATE keys SET last_used = ? WHERE key_code = ?
        RETURNING name
        ''', (datetime.now(), data))
        result = cursor.fetchone()
        conn.commit()
        
        if result:
            publish_event("access_granted", {"key_code": str(data), "name": result[0]})
            print(f"Access granted: {result[0]}")
            open_door()
            return result[0]
        else:
            publish_event("access_denied", {"key_code": str(data)})
            print("Access denied")
            return None
    except sqlite3.Error as e:
        print(f"Database error: {e}")
        return None

def open_door(duration=3):
    GPIO.output(OPEN_PIN, GPIO.HIGH)
    door_state.door_open = True
    light_control('green')
    publish_status()
    
    if door_state.mode:  # Short mode
        time.sleep(duration)
        close_door()

def close_door():
    GPIO.output(OPEN_PIN, GPIO.LOW)
    door_state.door_open = False
    light_control('red')
    publish_status()

def light_control(color):
    door_state.light_status = color
    if color == 'red':
        GPIO.output(GREEN_LIGHT_PIN, GPIO.HIGH)
        GPIO.output(RED_LIGHT_PIN, GPIO.LOW)
    elif color == 'green':
        GPIO.output(RED_LIGHT_PIN, GPIO.HIGH)
        GPIO.output(GREEN_LIGHT_PIN, GPIO.LOW)
    elif color == 'yellow':
        GPIO.output(RED_LIGHT_PIN, GPIO.LOW)
        GPIO.output(GREEN_LIGHT_PIN, GPIO.LOW)
    elif color == 'yellow_red':
        for _ in range(2):
            GPIO.output(RED_LIGHT_PIN, GPIO.LOW)
            GPIO.output(GREEN_LIGHT_PIN, GPIO.LOW)
            time.sleep(0.2)
            GPIO.output(GREEN_LIGHT_PIN, GPIO.HIGH)
            GPIO.output(RED_LIGHT_PIN, GPIO.LOW)
            time.sleep(0.2)
        light_control(door_state.light_status)
    publish_status()

def receive_data():
    GPIO.output(RS485_ENABLE_PIN, GPIO.LOW)
    if ser.in_waiting > 0:
        data = ser.read(ser.in_waiting)
        ser.reset_input_buffer()
        return data
    return None

# MQTT Callbacks
def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("Connected to MQTT Broker")
        client.subscribe(MQTT_TOPIC_CONTROL)
        publish_status()  # Отправляем текущий статус при подключении
    else:
        print(f"Failed to connect, return code {rc}")

def on_disconnect(client, userdata, rc):
    print(f"Disconnected with result code {rc}")
    time.sleep(5)
    client.reconnect()

def on_message(client, userdata, msg):
    try:
        message = msg.payload.decode()
        print(f"MQTT message received: {message}")
        
        if message == "open":
            open_door()
            door_state.block_mode = False
        elif message == "close":
            close_door()
        elif message == "long_mode":
            door_state.mode = False
            publish_event("mode_changed", {"new_mode": "long"})
            light_control('yellow_red')
        elif message == "short_mode":
            door_state.mode = True
            publish_event("mode_changed", {"new_mode": "short"})
            light_control('yellow_red')
        elif message == "get_status":
            publish_status()
            
    except Exception as e:
        print(f"Error processing MQTT message: {e}")

# Инициализация MQTT клиента
client = mqtt.Client()
client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
client.on_connect = on_connect
client.on_message = on_message
client.on_disconnect = on_disconnect
client.will_set(MQTT_TOPIC_STATUS, payload=json.dumps({"status": "offline"}), retain=True)

try:
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    client.loop_start()

    # Основной цикл
    while True:
        # Обработка карт
        card_data = receive_data()
        if card_data and not door_state.block_mode:
            print(f"Key code: {card_data}")
            if card_data in MASTER_CARDS:
                print("Master card detected. Waiting for new card...")
                while True:
                    new_card = receive_data()
                    if new_card:
                        name = input("Enter name for new card: ")
                        insert_key(new_card, name)
                        break
                    time.sleep(0.5)
            else:
                check_code_in_database(card_data)

        # Обработка кнопки
        press = detect_button_press(lambda: button.is_pressed)
        if press == 0:  # Длинное нажатие
            if not door_state.block_mode and door_state.door_open:
                close_door()
            door_state.block_mode = not door_state.block_mode
            publish_event("block_mode_toggled", {"new_state": door_state.block_mode})
            light_control('yellow' if door_state.block_mode else 'red')
            
        elif press == 1:  # Одинарное нажатие
            if door_state.door_open:
                close_door()
            else:
                open_door()
            door_state.block_mode = False
            
        elif press == 2:  # Двойное нажатие
            door_state.mode = not door_state.mode
            publish_event("mode_changed", {"new_mode": "long" if not door_state.mode else "short"})
            light_control('yellow_red')

        time.sleep(0.1)

except KeyboardInterrupt:
    print("Exiting...")
finally:
    client.loop_stop()
    client.disconnect()
    conn.close()
    ser.close()
    GPIO.cleanup()